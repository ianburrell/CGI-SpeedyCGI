/*
 * Copyright (C) 2001  Daemon Consulting Inc.
 * 
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 *
 */

#include "speedy.h"

/*
 * Accomodate 5.004
 */
#if PATCHLEVEL < 5
#define newSVpvn(s,l) my_newSVpvn(s,l)
SPEEDY_INLINE static SV *my_newSVpvn(char *s, int l) {
    return l ? newSVpv(s, l) : newSVpv("",0);
}
#endif

/*
 * Prior to perl 5.6.0 these funcs were prefixed with "perl_"
 */
#ifndef get_sv
#	define get_sv perl_get_sv
#endif
#ifndef get_av
#	define get_av perl_get_av
#endif
#ifndef get_cv
#	define get_cv perl_get_cv
#endif
#ifndef get_hv
#	define get_hv perl_get_hv
#endif
#ifndef call_sv
#	define call_sv perl_call_sv
#endif
#ifndef eval_sv
#	define eval_sv perl_eval_sv
#endif


/*
 * Convert integer to a hex-string in reverse.  Works for any number of bits
 */
#define HEX_STR_SIZE(type) (sizeof(type)*2)
#define NIB_TO_HEX(n) ("0123456789abcdef"[n])
#define HEX_CVT(i,b) \
    do { \
	*(b)++ = NIB_TO_HEX((i)&15); \
	(i) = (i) >> 4; \
    } while (i)

#define DEVFD "/dev/fd/%d"

#define DEVINO_STR_SIZE (HEX_STR_SIZE(dev_t)+HEX_STR_SIZE(ino_t)+2)
#define DEVINO_SAME(a,b) ((a).i == (b).i && (a).d == (b).d)
#define DEVINO_GET(fp,devino) PerlIO_read(fp, &(devino), sizeof(devino))
#define my_SvPV(sv) SvPV(sv, junk_len)
#define chdir_path_sv(sv) chdir_path(my_SvPV(sv), NULL)

typedef struct {
    int			refcnt;
    SV			*path;
    SpeedyDevIno	devino;
} SpeedyCwd;

typedef struct {
    CV		*handler;
    SpeedyCwd	*last_cwd;
} SpeedyScript;

typedef struct {
    void		*ptr;
    const svtype	type;
    const char		*name;
} SpeedyPerlVar;

/* Generated by util/perlvars */

#define PERLVAR_ENV               (SpeedyPerlVars[0])
#define PERLVAL_ENV               ((HV*)(SpeedyPerlVars[0].ptr))
#define PERLVAR_ARGV              (SpeedyPerlVars[1])
#define PERLVAL_ARGV              ((AV*)(SpeedyPerlVars[1].ptr))
#define PERLVAR_STDIN             (SpeedyPerlVars[2])
#define PERLVAL_STDIN             ((GV*)(SpeedyPerlVars[2].ptr))
#define PERLVAR_STDOUT            (SpeedyPerlVars[3])
#define PERLVAL_STDOUT            ((GV*)(SpeedyPerlVars[3].ptr))
#define PERLVAR_STDERR            (SpeedyPerlVars[4])
#define PERLVAL_STDERR            ((GV*)(SpeedyPerlVars[4].ptr))
#define PERLVAR_PROGRAM_NAME      (SpeedyPerlVars[5])
#define PERLVAL_PROGRAM_NAME      ((SV*)(SpeedyPerlVars[5].ptr))
#define PERLVAR_EVAL_ERROR        (SpeedyPerlVars[6])
#define PERLVAL_EVAL_ERROR        ((SV*)(SpeedyPerlVars[6].ptr))
#define PERLVAR_RESET_GLOBALS     (SpeedyPerlVars[7])
#define PERLVAL_RESET_GLOBALS     ((CV*)(SpeedyPerlVars[7].ptr))
#define PERLVAR_OPTS_CHANGED      (SpeedyPerlVars[8])
#define PERLVAL_OPTS_CHANGED      ((SV*)(SpeedyPerlVars[8].ptr))
#define PERLVAR_OPTS              (SpeedyPerlVars[9])
#define PERLVAL_OPTS              ((HV*)(SpeedyPerlVars[9].ptr))
#define PERLVAR_SHUTDOWN_HANDLER  (SpeedyPerlVars[10])
#define PERLVAL_SHUTDOWN_HANDLER  ((SV*)(SpeedyPerlVars[10].ptr))
#define PERLVAR_I_AM_SPEEDY       (SpeedyPerlVars[11])
#define PERLVAL_I_AM_SPEEDY       ((SV*)(SpeedyPerlVars[11].ptr))
#define PERLVAR_RUN_CLEANUP       (SpeedyPerlVars[12])
#define PERLVAL_RUN_CLEANUP       ((CV*)(SpeedyPerlVars[12].ptr))
#define PERLVAR_COUNT             13

static SpeedyPerlVar SpeedyPerlVars[] = {
    {NULL, SVt_PVHV , "ENV"},
    {NULL, SVt_PVAV , "ARGV"},
    {NULL, SVt_PVIO , "STDIN"},
    {NULL, SVt_PVIO , "STDOUT"},
    {NULL, SVt_PVIO , "STDERR"},
    {NULL, SVt_PV   , "0"},
    {NULL, SVt_PV   , "@"},
    {NULL, SVt_PVCV , "CGI::_reset_globals"},
    {NULL, SVt_IV   , "CGI::SpeedyCGI::_opts_changed"},
    {NULL, SVt_PVHV , "CGI::SpeedyCGI::_opts"},
    {NULL, SVt_PV   , "CGI::SpeedyCGI::_shutdown_handler"},
    {NULL, SVt_IV   , "CGI::SpeedyCGI::_i_am_speedy"},
    {NULL, SVt_PVCV , "CGI::SpeedyCGI::_run_cleanup"},
};

/* End of generated section */

static PerlInterpreter	*my_perl;
static slotnum_t	gslotnum, bslotnum;
static SpeedyCwd	*orig_cwd;
static int		cwd_fd = -1;
static const char 	*dev_null = "/dev/null";
static STRLEN		junk_len;
static HV		*cwd_hash, *scr_hash;

/*
 * Stuff to be stashed in cwd_hash / scr_hash
 *
 * %cwd{$devino_str} = SpeedyCwd*
 * %cwd{$path} = SpeedyCwd*
 * %script{$devino_str} = SpeedyScript*
 */

static int devino_str(SpeedyDevIno devino, char str[DEVINO_STR_SIZE]) {
    char *bp = str;
    ino_t i = devino.i;
    dev_t d = devino.d;

    HEX_CVT(i, bp);
    *bp++ = '_';
    HEX_CVT(d, bp);
    *bp = '\0';
    return bp - str;
}

/*
 * Debugging code to dump out the internal hashes - cwd_hash and scr_hash
 */

#ifdef DUMP_HASH

#define PRINTABLE(s) ((s) ? (s) : "NULL")

static void dump_cwd(SpeedyCwd *cwd, PerlIO *pio) {
    char dino_str[DEVINO_STR_SIZE];

    devino_str(cwd->devino, dino_str);
    PerlIO_printf(pio, "{refcnt=%d, path=%s, devino=%s}",
	cwd->refcnt, PRINTABLE(my_SvPV(cwd->path)), dino_str
    );
}

static void dump_hash(HV *hv, PerlIO *pio) {
    SV *sv;
    char *key;

    PerlIO_printf(pio, "Dump of %s_hash\n", hv == cwd_hash ? "cwd" : "script");
    hv_iterinit(hv);
    while ((sv = hv_iternextsv(hv, &key, &junk_len))) {
	PerlIO_printf(pio, "%s=", key);
	if (hv == scr_hash) {
	    SpeedyScript *scr = (SpeedyScript*)SvIV(sv);

	    PerlIO_printf(pio, "{handler=%x, last_cwd=", (int)(scr->handler));
	    if (scr->last_cwd)
		dump_cwd(scr->last_cwd, pio);
	    else
		PerlIO_printf(pio, "NULL");
	    PerlIO_printf(pio, "}\n");
	} else {
	    SpeedyCwd * cwd = (SpeedyCwd*)SvIV(sv);
	    dump_cwd(cwd, pio);
	    PerlIO_printf(pio, "\n");
	}
    }
}

#endif /* DUMP_HASH */


/* Locate a devino in one of the hashes */
static SV **find_devino(SpeedyDevIno devino, HV *hash, int lval) {
    char key[DEVINO_STR_SIZE];
    int key_len;

    key_len = devino_str(devino, key);
    return hv_fetch(hash, key, key_len, lval);
}

/* Find the SpeedyScript structure in the hash, using a devino key
 * Create a new one if not found.
 */
static SpeedyScript *find_scr(SpeedyDevIno devino, int *is_new) {
    SV *sv;
    SpeedyScript *retval;

    sv = find_devino(devino, scr_hash, 1)[0];

    if ((*is_new = !SvOK(sv))) {
	retval = speedy_malloc(sizeof(SpeedyScript));
	retval->handler = NULL;
	retval->last_cwd = NULL;
	sv_setiv(sv, (IV) retval);
    } else {
	retval = (SpeedyScript *) SvIV(sv);
    }

    return retval;
}

/* Get the directory that holds the filename */
static char *fname_dir(const char *p) {
    char *s;

    if (p && (s = strrchr(p, '/')))
	return speedy_util_strndup(p, max(1,s-p));
    else
	return NULL;
}

static void my_call_sv(SV *sv) {
    if (sv) {
	dSP;
	PUSHMARK(SP);
	call_sv(sv, G_DISCARD | G_NOARGS);
    }
}

SPEEDY_INLINE static void my_hv_store(HV* hash, char* key, int klen, SV* val) {
    if (!hv_store(hash, key, (klen == -1 ? strlen(key) : klen), val, 0))
	SvREFCNT_dec(val);
}

static void cwd_refcnt_dec(SpeedyCwd *cwd) {
    if (!--(cwd->refcnt)) {
	char key[DEVINO_STR_SIZE];
	int key_len;

	key_len = devino_str(cwd->devino, key);
	hv_delete(cwd_hash, key, key_len, G_DISCARD);

	hv_delete_ent(cwd_hash, cwd->path, G_DISCARD, 0);
	SvREFCNT_dec(cwd->path);
	speedy_free(cwd);
    }
}

static int stat_cwd_fd(SpeedyDevIno *devino) {
    struct stat stbuf;

    if (cwd_fd != -1) {
	if (fstat(cwd_fd, &stbuf) != -1) {
	    *devino = speedy_util_stat_devino(&stbuf);
	    return 1;
	}
	close(cwd_fd);
	cwd_fd = -1;
    }
    return 0;
}

static int chdir_path(const char *path, SpeedyDevIno *devino) {
    int retval;

    if (!path || !path[0])
	return 0;

    if (cwd_fd != -1)
	close(cwd_fd);
    retval = path
	? (((path[0] == '.' && path[1] == '\0')) ? 0 : chdir(path))
	: -1;
    cwd_fd = retval != -1
	? speedy_util_pref_fd(open(".", O_RDONLY), PREF_FD_CWD)
	: -1;

    /* TEST - simulate unreadable "." directory */
    /* close(cwd_fd); cwd_fd = -1; */
    
    /* Get device/inode for "." */
    if (retval != -1 && devino && !stat_cwd_fd(devino)) {
	struct stat stbuf;

	if (cwd_fd == -1) {
	    if (stat(".", &stbuf) == -1) {
		devino->d = 0;
		devino->i = 0;
	    }
	} else {
	    *devino = speedy_util_stat_devino(&stbuf);
	}
    }
    return retval;
}

static int quick_cd(SpeedyDevIno dest) {
    SpeedyDevIno devino;

    /*
     * See if cwd_fd is the correct dir - if so fchdir there.
     */
    if (stat_cwd_fd(&devino) && DEVINO_SAME(dest, devino) &&
	fchdir(cwd_fd) != -1)
    {
	return 1;
    }

    /* Stat "." */
    chdir_path(".", &devino);

    /* See if "." is the right directory */
    return DEVINO_SAME(dest, devino);
}

/* Remove myself from the temp file */
static void remove_from_temp() {
    if (bslotnum && gslotnum) {
	speedy_file_set_state(FS_WRITING);
	speedy_backend_check_next(gslotnum, bslotnum);
	speedy_backend_dispose(gslotnum, bslotnum);
	speedy_group_cleanup(gslotnum);
	bslotnum = gslotnum = 0;
    }
}

/* Shutdown and exit. */
static void all_done(int exec_myself) {

    /* Re-open the file to make sure we're not going to remove a temp
     * file belonging to a newer backend using this slot in a newer
     * version of this file
     */
    speedy_file_set_state(FS_HAVESLOTS);
    speedy_file_need_reopen();

    if (exec_myself) {
	if (bslotnum) {
	    /* Lower the maturity level for this slot */
	    speedy_file_set_state(FS_WRITING);
	    FILE_SLOT(be_slot, bslotnum).maturity = 0;
	}
    } else {
	remove_from_temp();
    }
    speedy_file_set_state(FS_CLOSED);

    /* Destroy the interpreter */
    if (my_perl) {

	/* Call the shutdown handler if present */
	if (my_SvPV(PERLVAL_SHUTDOWN_HANDLER)[0])
	    my_call_sv(PERLVAL_SHUTDOWN_HANDLER);

	perl_destruct(my_perl);
    }
    if (exec_myself) {
	/* Flush all open files */
	PerlIO_flush(NULL);

	/* Chdir back to where we started */
	if (orig_cwd && !quick_cd(orig_cwd->devino))
	    chdir_path_sv(orig_cwd->path);

	speedy_util_execvp((speedy_opt_orig_argv()[0]), speedy_opt_orig_argv());

	/* Failed, so remove ourself from the temp file */
	remove_from_temp();
    }
    speedy_util_exit(0,0);
}

/* Signal handler */
static Signal_t doabort_sig(int x) {
    all_done(0);
}

/* Wait for a connection from a frontend */
static void backend_accept() {
    /* Loop forever */
    while (1) {

	/* Wait for an accept or timeout */
	if (speedy_ipc_accept(OPTVAL_TIMEOUT*1000) || speedy_ipc_accept(0)) {
	    /* Got an accept */
	    return;
	}
	all_done(0);
    }
}


/* Read in a string on stdin. */
SPEEDY_INLINE static int get_string(PerlIO *pio_in, char **buf) {
    int sz;

    /* Read length of string */
    sz = PerlIO_getc(pio_in);

    switch(sz) {
    case -1:
	DIE_QUIET("protocol error");
    case 0:
	*buf = NULL;
	break;
    case MAX_SHORT_STR:
	PerlIO_read(pio_in, &sz, sizeof(int));
	/* Fall through */
    default:
	{
	    /* Allocate space */
	    char *b = *buf = speedy_malloc(sz+1);

	    /* Read string and terminate */
	    PerlIO_read(pio_in, b, sz);
	    b[sz] = '\0';
	}
	break;
    }
    return sz;
}

static void do_proto2(char **cwd_path) {
    char c;

    /* Tell the frontend what we need */
    c = cwd_path ? 1 : 0;
    write(PREF_FD_ACCEPT_O, &c, 1);

    if (cwd_path) {
	PerlIO *pio_file = PerlIO_fdopen(dup(PREF_FD_ACCEPT_E), "r");

	/* Get cwd */
	get_string(pio_file, cwd_path);

	PerlIO_close(pio_file);
    }
}

/* Catch pesky signals */
static void set_sigs() {
    rsignal(SIGPIPE, &doabort_sig);
    rsignal(SIGALRM, &doabort_sig);
    rsignal(SIGTERM, &doabort_sig);
    rsignal(SIGHUP,  &doabort_sig);
    rsignal(SIGINT,  &doabort_sig);
}

static void *get_perlvar(SpeedyPerlVar *pv) {
    if (!pv->ptr) {
	switch(pv->type) {
	    case SVt_PVIO:
		pv->ptr = gv_fetchpv((char*)pv->name, 1, SVt_PVIO);
		break;
	    case SVt_PVAV:
		pv->ptr = get_av((char*)pv->name, 1);
		break;
	    case SVt_PVHV:
		pv->ptr = get_hv((char*)pv->name, 1);
		break;
	    case SVt_PVCV:
		pv->ptr = get_cv((char*)pv->name, 0);
		break;
	    default:
		pv->ptr = get_sv((char*)pv->name, 1);
		break;
	}
	if (pv->type != SVt_PVCV && !pv->ptr)
	    DIE_QUIET("Cannot create perl variable %s", pv->name);
    }
    return pv->ptr;
}

static SpeedyCwd *cwd_new(const char *path, int path_is_dot) {
    char key[DEVINO_STR_SIZE];
    int key_len;
    SV *sv;
    SpeedyCwd *cwd = speedy_malloc(sizeof(SpeedyCwd));

    /* Chdir to the given path */
    if (!path || chdir_path((path_is_dot ? "." : path), &(cwd->devino)) == -1) {
	speedy_free(cwd);
	return NULL;
    }

    /* Make a new cwd structure */
    cwd->refcnt = 0;
    cwd->path = newSVpv((char*)path, 0);

    /* Store in the hash */
    sv = newSViv((IV)cwd);
    SvREFCNT_inc(sv);

    key_len = devino_str(cwd->devino, key);
    my_hv_store(cwd_hash, key, key_len, sv);

    if (!hv_store_ent(cwd_hash, cwd->path, sv, 0))
	SvREFCNT_dec(sv);

    return cwd;
}

static void store_last_cwd(SpeedyCwd **last_cwd, SpeedyCwd *cwd) {
    SpeedyCwd *prev_ptr = *last_cwd;

    cwd->refcnt++;
    *last_cwd = cwd;
    if (prev_ptr)
	cwd_refcnt_dec(prev_ptr);
}

#define PACKAGE_FMT	"CGI::SpeedyCGI::_%s"
#define COLON_HANDLER	"::handler"

static void load_script(
    SpeedyDevIno devino, SpeedyScript *scr, const char *scr_path
)
{
    SV *sv;
    char pkg[sizeof(PACKAGE_FMT)+DEVINO_STR_SIZE+sizeof(COLON_HANDLER)+5];

    /* Get package name */
    {
	char hex_str[DEVINO_STR_SIZE];
	devino_str(devino, hex_str);
	sprintf(pkg, PACKAGE_FMT, hex_str);
    }

    /* Create phony package in sv with the script code in the handler func */
    {
	struct stat stbuf;
	SpeedyMapInfo *mi = NULL;
	int fd;

	/* Grab the contents of the file */
	if ((fd = speedy_util_open_stat(scr_path, &stbuf)) != -1) {
	    mi = speedy_util_mapin(fd, -1, stbuf.st_size);
	    close(fd);
	}
	if (fd == -1 || mi == NULL)
	    speedy_util_die(scr_path);

	/* Create sv to eval */
	sv = newSVpvf("package %s; sub handler { ", pkg);
	sv_catpvn(sv, mi->addr, mi->maplen);
	sv_catpvn(sv, "; }", 3);

	/* Get rid of the file contents */
	speedy_util_mapout(mi);
    }

    /* Evaluate the sv to create the handler */
    {
	dSP;
	PUSHMARK(SP);
	eval_sv(sv, G_DISCARD | G_NOARGS | G_VOID | G_EVAL | G_KEEPERR);
    }
    SvREFCNT_dec(sv);

    /* See if we got an eval error */
    if (SvTRUE(PERLVAL_EVAL_ERROR)) {
	scr->handler = NULL;
    } else {
	strcat(pkg, COLON_HANDLER);
	scr->handler = get_cv(pkg, 0);
    }
    if (!scr->handler) {
	DIE_QUIET("Could not compile code for %s: %s",
	    scr_path, my_SvPV(PERLVAL_EVAL_ERROR));
    }
}

/* One run of the perl process, do stdio using socket. */
static void onerun(int single_script) {
    int sz, new_script, cwd_where;
    char *buf, *scr_path, *s;
    SpeedyDevIno fe_scr;
    SpeedyScript *scr;
    pid_t mypid = speedy_util_getpid();
    PerlIO *pio_in, *pio_out, *pio_err;

    pio_in  = PerlIO_stdin();
    pio_out = PerlIO_stdout();
    pio_err = PerlIO_stderr();

    /* Set up perl STD* filehandles to have the PerlIO file pointers */
    IoIFP(GvIOp(PERLVAL_STDIN))  = IoOFP(GvIOp(PERLVAL_STDIN))  = pio_in;
    IoIFP(GvIOp(PERLVAL_STDOUT)) = IoOFP(GvIOp(PERLVAL_STDOUT)) = pio_out;
    IoIFP(GvIOp(PERLVAL_STDERR)) = IoOFP(GvIOp(PERLVAL_STDERR)) = pio_err;

    /* Do "select STDOUT" */
    setdefout(PERLVAL_STDOUT);

    /* TEST - this should cause a "protocol error" */
    /* close(0); */

    /* Get info from the frontend. */

    /*
     * %ENV
     */

    /* Undef it */
    hv_undef(PERLVAL_ENV);

    /* Read in environment from stdin. */
    while ((sz = get_string(pio_in, &buf))) {

	/* Find equals. Store key/val in %ENV */
	if ((s = strchr(buf, '='))) {
	    int i = s - buf;
	    SV *sv = newSVpvn(s+1, sz-(i+1));
	    my_hv_store(PERLVAL_ENV, (char*)buf, i, sv);
	    *s = '\0';
	    my_setenv(buf, s+1);
	}
	speedy_free(buf);
    }

    /*
     * @ARGV
     */

    /* Undef it. */
    av_undef(PERLVAL_ARGV);

    /* Read in argv from stdin. */
    while ((sz = get_string(pio_in, &buf))) {
	SV *sv = newSVpvn(buf, sz);
	av_push(PERLVAL_ARGV, sv);
	speedy_free(buf);
    }

    /*
     * Script filename
     */
    get_string(pio_in, &scr_path);

    /*
     * Script device/inode
     */
    DEVINO_GET(pio_in, fe_scr);

    /*
     * Find the script structure for this script
     */
    scr = find_scr(fe_scr, &new_script);

    /*
     * Is cwd part of the script filename?
     */
    cwd_where = PerlIO_getc(pio_in);
    if (cwd_where == SPEEDY_CWD_IN_SCRIPT) {
	char *dir;

	/* Get directory from the script path */
	if ((dir = fname_dir(scr_path))) {
	    SV **sv;
	    int done = 0;
	    SpeedyCwd *cwd = NULL;
	    
	    /* Look up path in hash to find SpeedyCwd and device/inode */
	    if ((sv = hv_fetch(cwd_hash, dir, strlen(dir), 0))) {
		cwd = (SpeedyCwd*)SvIV(*sv);
		
		/* Try to cd there quickly without using a path */
		done = quick_cd(cwd->devino);
	    }
	    if (!done) {
		/* Chdir to the path the frontend gave us and get its cwd */
		cwd = cwd_new(dir, 0);
	    }

	    /* Store the cwd struct with this script */
	    store_last_cwd(&(scr->last_cwd), cwd);
	    speedy_free(dir);
	}
    } else {
	int did_proto2 = 0, done = 0;
	SpeedyCwd *cwd = NULL;

	/* Is frontend passing over cwd's device/inode */
	if (cwd_where == SPEEDY_CWD_DEVINO) {
	    SpeedyDevIno fe_cwd;

	    /* Get cwd device/inode from frontend */
	    DEVINO_GET(pio_in, fe_cwd);

	    /* Try to quickly get there without using a path */
	    done = quick_cd(fe_cwd);

	    if (!done) {
		/* Try using the path in last_cwd in the script struct */
		done = scr->last_cwd &&
		    DEVINO_SAME(fe_cwd, scr->last_cwd->devino) &&
		    chdir_path_sv(scr->last_cwd->path) != -1;

		/* Didn't work.  Try to look up device/inode in hash */
		if (!done) {
		    SV **sv;

		    if ((sv = find_devino(fe_cwd, cwd_hash, 0))) {
			cwd = (SpeedyCwd*)SvIV(*sv);

			/* If found, go to that path */
			done = (chdir_path_sv(cwd->path) != -1);
		    }
		}
	    }
	}
	if (!done) {
	    char *dir;
	    /*
	     * Do proto2 with frontend to get path
	     */
	    do_proto2(&dir);
	    did_proto2 = 1;
	    
	    /* Cd to this path and get its cwd structure back */
	    if (dir) {
		cwd = cwd_new(dir, 0);
		speedy_free(dir);
	    }
	}

	/* If we used a cwd structure, make sure to save it */
	if (cwd)
	    store_last_cwd(&(scr->last_cwd), cwd);

	/* Must do proto2 if not already done */
	if (!did_proto2)
	    do_proto2(NULL);
    }

    /*
     * Load the script if it's new
     */
    if (new_script)
	load_script(fe_scr, scr, scr_path);

    /* Set $0 to the script filename */
    sv_setpv(PERLVAL_PROGRAM_NAME, scr_path);
    speedy_free(scr_path);

    /* Run the perl code.  Ignore return value since we want to stay persistent
     * no matter what the return code.
     */
    if (single_script) {
	(void) perl_run(my_perl);
    } else {
	dSP;
	int i, argv_len = av_len(PERLVAL_ARGV);
	SV **svp;

	ENTER;
	SAVETMPS;
	PUSHMARK(SP);

	/* Make room on the stack for the array */
	EXTEND(SP, argv_len+1);

	/* Copy @ARGV onto the stack so things like shift/pop work */
	for (i = 0; i <= argv_len; ++i) {
	    if ((svp = av_fetch(PERLVAL_ARGV, i, 0))) {
		SV *sv = *svp;
		PUSHs(sv_2mortal(newSVsv(sv)));
	    }
	}
	PUTBACK;

	/* Call the handler */
	call_sv((SV*)scr->handler, G_DISCARD);

	FREETMPS;
	LEAVE;
    }
    speedy_util_time_invalidate();

    /* Terminate any forked children */
    if (getpid() != mypid)
	speedy_util_exit(0,0);

    /* Call any cleanup functions */
    my_call_sv(get_perlvar(&PERLVAR_RUN_CLEANUP));

    /* Flush output, in case perl's stdio/reopen below don't */
    PerlIO_flush(pio_out);
    PerlIO_flush(pio_err);

    /* Close down perl's STD* files (might not be the same as PerlIO files) */
    do_close(PERLVAL_STDOUT, FALSE);
    do_close(PERLVAL_STDERR, FALSE);
    do_close(PERLVAL_STDIN,  FALSE);

    /* Get stdio files back in shape */
    PerlIO_reopen(dev_null, "r", pio_in);
    PerlIO_reopen(dev_null, "w", pio_out);
    PerlIO_reopen(dev_null, "w", pio_err);
    close(0); close(1); close(2);

    /* Reset signals */
    set_sigs();

    /* Hack for CGI.pm */
    my_call_sv(get_perlvar(&PERLVAR_RESET_GLOBALS));

#ifdef DUMP_HASH
    {
	time_t t;

	PerlIO *pio = PerlIO_open("/tmp/speedy_backend_dump", "a");
	t = time(NULL);
	PerlIO_printf(pio, "\npid=%d time=%s\n",
	    speedy_util_getpid(), asctime(localtime(&t)));
	dump_hash(cwd_hash, pio);
	dump_hash(scr_hash, pio);
	PerlIO_close(pio);
    }
#endif
}

/* Called from xs_init */
void speedy_xs_init() {
    int i;
    SV *sv;

    /*
     * Put things here that have to be done in the perl interpreter before
     * a script runs its BEGIN block.
     */

    /* Find/create our perl vars in the interpreter */
    for (i = 0; i < PERLVAR_COUNT; ++i) {
	(void) get_perlvar(SpeedyPerlVars + i);
    }
    scr_hash = newHV();
    cwd_hash = newHV();

    /* Tell our module that we are speedycgi */
    sv_inc(PERLVAL_I_AM_SPEEDY);

    /* Save our current directory now in case script changes it */
    if ((orig_cwd = cwd_new(speedy_util_getcwd(), 1)))
	orig_cwd->refcnt++;

    /*
     * Initialize options variables in our module.
     */
    for (i = 0; i < SPEEDY_NUMOPTS; ++i) {
	OptRec *o = speedy_optdefs + i;
	if (o->type == OTYPE_STR) {
	    if (!o->value) continue;
	    sv = newSVpv((char*)o->value, 0);
	} else {
	    sv = newSViv((int)o->value);
	}
	my_hv_store(PERLVAL_OPTS, (char*)o->name, o->name_len, sv);
    }
}

void speedy_perl_run(slotnum_t _gslotnum, slotnum_t _bslotnum)
{
    int numrun, i;
    char **perl_argv;
    const char *temp_script_name;
    int use_devfd, single_script;
    char dev_fd_name[sizeof(DEVFD)+10];
    SpeedyScript *scr;
    extern void xs_init();

    /* Copy into globals */
    gslotnum		= _gslotnum;
    bslotnum		= _bslotnum;
    single_script	= DOING_SINGLE_SCRIPT;

    /* Catch signals */
    set_sigs();

    /* Allocate and construct new perl */
    if (!(my_perl = perl_alloc()))
	DIE_QUIET("Cannot allocate perl");
    perl_construct(my_perl);

    /* If we're exec'ing a setuid script then we must use a temporary
     * script name of /dev/fd/N 
     */
    use_devfd = single_script &&
                speedy_script_getstat()->st_mode & (S_ISUID|S_ISGID);

    if (single_script) {
	if (use_devfd) {
	    sprintf(dev_fd_name, DEVFD, speedy_script_open());
	    temp_script_name = dev_fd_name;
	} else {
	    temp_script_name = NULL;
	}
    } else {
	temp_script_name = dev_null;
    }

    /* Parse perl file. */
    perl_argv = speedy_opt_perl_argv(temp_script_name);
    if (perl_parse(my_perl, xs_init,
	speedy_util_argc((const char * const *)perl_argv), perl_argv, NULL))
    {
	DIE_QUIET("perl_parse error");
    }

    /* If we had to use /dev/fd/N, perl will close the file for us, so
     * make sure our code knows it's closed.  If we need it from here on out
     * it'll have to be re-opened.
     */
    if (use_devfd)
	speedy_script_close();

    /* Create a SpeedyScript entry for the standard script */
    scr = find_scr(speedy_util_stat_devino(speedy_script_getstat()), &i);

    /* If using groups, try pre-loading the script to save time later */
    if (!single_script && !speedy_script_open_failure()) {
	load_script(
	    speedy_util_stat_devino(speedy_script_getstat()),
	    scr, speedy_opt_script_fname()
	);
    }

    /* Make sure script is closed */
    speedy_script_close();

    /* Time to close stderr */
    close(2);

    /* Start listening on our socket */
    speedy_ipc_listen(bslotnum);

    /* Main loop */
    for (numrun = 0; !OPTVAL_MAXRUNS || numrun < OPTVAL_MAXRUNS; ++numrun) {

	/* Lock/mmap our temp file */
	speedy_file_set_state(FS_WRITING);

	/* If our group is invalid, exit quietly */
	if (!speedy_group_isvalid(gslotnum)) {
	    gslotnum = 0;
	    speedy_file_set_state(FS_HAVESLOTS);
	    all_done(0);
	}

	/* Check our backend siblings */
	speedy_backend_check_next(gslotnum, bslotnum);

	/* Update our maturity level */
	FILE_SLOT(be_slot, bslotnum).maturity = numrun ? 2 : 1;

	/* Put ourself onto the be_wait list */
	speedy_backend_be_wait_put(gslotnum, bslotnum);

	/* Send out alarm signal to frontends */
	speedy_group_sendsigs(gslotnum);

	/* Fix our listener fd */
	speedy_ipc_listen_fixfd(bslotnum);

	/* Unlock file */
	speedy_file_set_state(FS_HAVESLOTS);

	/* Do an accept on our socket */
	backend_accept();

	/* Run the perl code once */
	onerun(single_script);

	/* Tell our file code that its fd is suspect */
	speedy_file_fd_is_suspect();

	/* See if we should get new options from the perl script */
	if (SvIV(PERLVAL_OPTS_CHANGED)) {
	    for (i = 0; i < SPEEDY_NUMOPTS; ++i) {
		OptRec *o = speedy_optdefs + i;
		SV **svp =
		    hv_fetch(PERLVAL_OPTS, (char*)o->name, o->name_len, 0);
		if (svp)
		    (void) speedy_opt_set(o, my_SvPV(*svp));
	    }
	    sv_setiv(PERLVAL_OPTS_CHANGED, 0);
	}
    }
    all_done(1);
}

/*
 * Glue
 */

void speedy_abort(const char *s) {
    PerlIO_puts(PerlIO_stderr(), s);
    speedy_util_exit(1, 0);
}
